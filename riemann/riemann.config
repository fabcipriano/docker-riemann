; -*- mode: clojure; -*-
; vim: filetype=clojure

; Import
(require  '[clj-http.client :as client]
          '[cheshire.core :as json])

; Init logging. No file parameter, log to stdout.
(logging/init)

; Listen on the local interface over TCP (5555), UDP (5555), and websockets
; (5556)
(let [host "0.0.0.0"]
  (tcp-server {:host host})
  (udp-server {:host host})
  (ws-server  {:host host}))

; Include all config files found in directory
(include "/etc/riemann/conf.d")

; COnfig Slack API Bot for Riemann
(defn make_alarm_text [events] (str "Houston We have a problem!\n\n App.: Test App Server - HOM\n Alarm Event.: " events))

(defn formatt_alarm_text [events] (str "Houston We have a problem!\n\n App.: Test App Server - HOM\n\ Alarm Event.: " (peek events)))

(defn simple_slack_api [alarm_msg] 
    (client/post "https://hooks.slack.com/services/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" 
        {:form-params 
            {:payload (json/generate-string 
                {:text alarm_msg 
                :channel "#alarms" :username "friemann-bot" :icon_emoji ":alarm_clock:"})}}))

; format ElasticSearch Index String
(defn makeindexstr [event] (str "testapp.tst." (:service event)))

; Remove riemann events
(instrumentation {:enabled? false})

; Expire old events from the index every 10 seconds.
(periodically-expire 10 {:keep-keys [:host :service :tags, :state, :description, :metric]})

; Configure Streams Riemann
(let [index (index)]
(streams
  (default :ttl 60

  ; Index all events immediately
  index
    
  ;Send events to ELK
  (by :service
    (fn [event]
      ((elasticsearch {:es-endpoint "http://elasticmon:9200" :es-index (makeindexstr event)}) event)))
  
  ;Send alarms of expired events to Slacker
  (expired
    (rollup 5 3600
      (fn [event]
        (prn (str "------- Send ALARM to Slacker.: " (make_alarm_text event)))
        (simple_slack_api (make_alarm_text event)))))

  #(info %))))
